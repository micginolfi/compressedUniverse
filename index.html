<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Compressed Universe Viewer</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    
    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; height: 100vh; display: flex; flex-direction: column; overflow: hidden; background: #f4f4f4; }
        #main-container { display: flex; flex: 1; height: 60%; min-height: 200px; border-bottom: 5px solid #ccc; resize: vertical; overflow: auto; }
        #left-panel { flex: 1; border-right: 1px solid #ccc; position: relative; min-width: 300px; }
        #right-panel { flex: 2; display: flex; flex-direction: column; min-width: 600px; }
        
        #sed-container { display: flex; flex: 1; }
        #sed-observer { flex: 1; border-right: 1px solid #ccc; }
        #sed-restframe { flex: 1; display: flex; flex-direction: column; }
        #histogram-panel { height: 120px; border-bottom: 1px solid #ccc; background: #fafafa; }
        #sed-rest-plot { flex: 1; }
        
        
        #bottom-container { flex: 1; display: flex; min-height: 220px; background: #f4f4f4; }
        #barro-panel { flex: 0.5; border-right: 1px solid #ccc; background: white; min-width: 300px; display: flex; flex-direction: column; }
        #barro-header { padding: 8px 10px; background: #f8f9fa; border-bottom: 1px solid #ddd; font-size: 13px; color: #333; }

        #iframe-container { flex: 1; background: white; display: flex; flex-direction: column; min-height: 220px; }
        #iframe-container { border-left: 1px solid #ccc; }
        .plot-div { width: 100%; height: 100%; }
        
        #controls { padding: 8px 15px; background: #333; color: white; border-bottom: 1px solid #000; display: flex; align-items: center; font-size: 14px; }
        
        #color-controls { 
            padding: 8px 15px; 
            background: #444; 
            color: white; 
            border-bottom: 1px solid #222; 
            display: flex; 
            align-items: center; 
            gap: 15px;
            font-size: 13px;
        }
        
        .color-btn {
            padding: 5px 12px;
            background: #666;
            color: white;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.2s;
        }
        
        .color-btn:hover {
            background: #777;
        }
        
        .color-btn.active {
            background: #007bff;
            border-color: #0056b3;
        }
        
        #browser-header { padding: 10px; background: #f8f9fa; border-bottom: 1px solid #ddd; font-size: 14px; font-family: sans-serif; line-height: 1.5; }
        
        iframe { width: 100%; height: 100%; border: none; }
        
        .info-tag { padding: 3px 6px; border-radius: 3px; color: white; font-weight: bold; font-size: 0.9em; margin-right: 5px; display: inline-block; }
        .stat-tag { background: #6c757d; color: white; padding: 2px 6px; border-radius: 3px; font-weight: bold; font-size: 0.9em; }
        
        .morph-info {
            background: #f8f9fa;
            border-left: 3px solid #007bff;
            padding: 8px 12px;
            margin: 8px 0;
            font-size: 13px;
            line-height: 1.6;
        }
        
        .morph-info b {
            color: #333;
        }
        
        #error-overlay { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); z-index: 9999; padding: 40px; color: #d62728; font-family: monospace; white-space: pre-wrap; font-size: 16px; border: 5px solid #d62728;}
        #loading-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,1); z-index: 5000; display: flex; justify-content: center; align-items: center; font-size: 1.5em; color: #333; flex-direction: column;}
        
        /* Dataset selection overlay */
        #dataset-selection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* MODIFICA: Sfondo bianco */
            background: white;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        #dataset-selection-overlay h1 {
            /* MODIFICA: Colore testo scuro per sfondo bianco */
            color: #333;
            font-size: 2.5em;
            margin-bottom: 50px;
            /* Rimosso text-shadow pesante per leggibilit√† su bianco, o ridotto */
            text-shadow: none;
        }
        
        .dataset-container {
            display: flex;
            gap: 40px;
            align-items: center;
            justify-content: center;
        }
        
        .dataset-box {
            width: 350px;
            height: 250px; /* Aumentato leggermente per testo lungo */
            background: white;
            border-radius: 12px;
            /* Ombra pi√π definita per contrasto su sfondo bianco */
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            border: 1px solid #eee;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            padding: 30px;
            text-align: center;
        }
        
        .dataset-box:hover {
            transform: translateY(-10px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.25);
            border-color: #007bff;
        }
        
        .dataset-box h2 {
            color: #333;
            font-size: 1.5em;
            margin: 0;
            line-height: 1.4;
        }
    </style>
</head>
<body>

    <!-- Dataset Selection Overlay -->
    <div id="dataset-selection-overlay">
        <h1>Choose the dataset to explore</h1>
        <div class="dataset-container">
            <!-- Box 1 -->
            <div class="dataset-box" onclick="selectDataset('withcontaminants')">
                <h2>Full Dataset<br>
                    <span style="font-size: 0.6em; color: #666; font-weight: normal;">
                        simultaneous &gt;2sigma detections
                    </span>
                </h2>
            </div>
            
            <!-- Box 2 -->
            <div class="dataset-box" onclick="selectDataset('nocontaminants')">
                <h2>Dataset with no contaminants<br>
                    <span style="font-size: 0.6em; color: #666; font-weight: normal;">
                        simultaneous &gt;2sigma detections, removed sources with possible SED contamination (i.e., companions &lt; 0.5")
                    </span>
                </h2>
            </div>

            <!-- Box 3 -->
            <div class="dataset-box" onclick="selectDataset('onlymorphology')">
                <h2>Full dataset with no contaminants and no morphology<br>
                    <span style="font-size: 0.5em; color: #666; font-weight: normal;">
                        simultaneous &gt;2sigma detections, removed sources with possible SED contamination (i.e., companions &lt; 0.5"), removed stellarity and r50 as input features (only colours, 0.1 * scaling flux and photo-z)
                    </span>
                </h2>
            </div>
        </div>
    </div>

    <div id="error-overlay"></div>
    <div id="loading-overlay">
        <div>‚è≥ Loading & Decompressing Data...</div>
        <div id="loading-filename" style="font-size:0.6em; color:#666; margin-top:10px">Fetching galaxy_data.js.gz</div>
    </div>

    <script>
        let selectedDataFile = null;

        function selectDataset(type) {
            // MODIFICA: Logica selezione file aggiornata
            if (type === 'withcontaminants') {
                selectedDataFile = 'galaxy_data_withcontaminants.js.gz';
            } else if (type === 'nocontaminants') {
                selectedDataFile = 'galaxy_data_nocontaminants.js.gz';
            } else if (type === 'onlymorphology') {
                selectedDataFile = 'galaxy_data_onlymorphology.js.gz';
            }
            
            document.getElementById('dataset-selection-overlay').style.display = 'none';
            document.getElementById('loading-overlay').style.display = 'flex';
            document.getElementById('loading-filename').textContent = `Fetching ${selectedDataFile}`;
            
            loadData();
        }

        function showError(msg) {
            document.getElementById('loading-overlay').style.display = 'none';
            const el = document.getElementById('error-overlay');
            el.style.display = 'block';
            el.innerHTML = "<h3>‚ö†Ô∏è CRITICAL ERROR</h3>" + msg;
            console.error(msg);
        }

        async function loadData() {
            try {
                const response = await fetch(selectedDataFile);
                if (!response.ok) throw new Error(`HTTP Error ${response.status}: ${response.statusText}`);

                const ds = new DecompressionStream('gzip');
                const decompressedStream = response.body.pipeThrough(ds);

                const blob = await new Response(decompressedStream).blob();
                const scriptContent = await blob.text();

                const script = document.createElement('script');
                script.text = scriptContent;
                document.body.appendChild(script);

                document.getElementById('loading-overlay').style.display = 'none';
                initDashboard();

            } catch (err) {
                let extra = "";
                if (window.location.protocol === 'file:') {
                    extra = "\n\n‚ö†Ô∏è NOTE: You are running via 'file://'.\nRun a local server: python -m http.server";
                }
                showError("Failed to load " + selectedDataFile + ":\n" + err.message + extra);
            }
        }
    </script>

    <div id="controls">
        <b style="font-size:1.1em; margin-right: 20px;">Compressed Universe Viewer + DJA</b> 
        <span style="color:#aaa; font-size:0.9em; flex: 1;">
            üñ±Ô∏è <b>Click:</b> Single object &nbsp;|&nbsp; 
            ‚≠ï <b>Lasso/Box:</b> Stacked SED
        </span>
        <button id="download-btn" disabled style="padding: 4px 10px; cursor: pointer; background: #555; border: 1px solid #777; color: white; border-radius: 4px; font-size: 0.9em;">
            ‚¨á Scarica CSV
        </button>
    </div>

    <div id="color-controls">
        <span style="font-weight: bold;">Color by:</span>
        <button class="color-btn active" data-mode="catalogs">Catalogs</button>
        <button class="color-btn" data-mode="zphot">Photo-z</button>
        <button class="color-btn" data-mode="ref_flux">Flux Scale</button>
        <button class="color-btn" data-mode="classstar">ClassStarSE</button>
    </div>

    <div id="main-container">
        <div id="left-panel">
            <div id="umap-plot" class="plot-div"></div>
        </div>
        <div id="right-panel">
            <div id="sed-container">
                <div id="sed-observer">
                    <div id="sed-plot" class="plot-div"></div>
                </div>
                <div id="sed-restframe">
                    <div id="histogram-panel">
                        <div id="histogram-plot" class="plot-div"></div>
                    </div>
                    <div id="sed-rest-plot" class="plot-div"></div>
                </div>
            </div>
        </div>
    </div>

    
    <div id="bottom-container">
        <div id="barro-panel">
            <div id="barro-header">
                <b>Barro-style Color‚ÄìColor Diagram</b>
                <span style="color:#666; font-size:0.9em;">&nbsp; (F115W‚àíF200W vs F200W‚àíF444W)</span>
                <span id="barro-count" style="float:right; color:#007bff; font-weight:bold;">Selected: 0</span>
            </div>
            <div id="barro-plot" class="plot-div"></div>
        </div>

        <div id="iframe-container">
            <div id="browser-header">Waiting for selection...</div>
            <iframe id="dja-frame" src="about:blank"></iframe>
        </div>
    </div>

<script>
    function initDashboard() {
        try {
            if (typeof window.GALAXY_DATA === 'undefined') throw new Error("GALAXY_DATA missing");
            const D = window.GALAXY_DATA;
            
            let currentSelectionIndices = [];
            const downloadBtn = document.getElementById('download-btn');

            downloadBtn.addEventListener('click', function() {
                if (currentSelectionIndices.length === 0) return;
                downloadCsv(currentSelectionIndices);
            });

            function updateDownloadButtonState() {
                if (currentSelectionIndices.length > 0) {
                    downloadBtn.disabled = false;
                    downloadBtn.style.background = "#28a745"; // Verde quando attivo
                    downloadBtn.style.border = "1px solid #1e7e34";
                    downloadBtn.innerText = `‚¨á Scarica CSV (${currentSelectionIndices.length})`;
                } else {
                    downloadBtn.disabled = true;
                    downloadBtn.style.background = "#555"; // Grigio quando disattivo
                    downloadBtn.style.border = "1px solid #777";
                    downloadBtn.innerText = "‚¨á Scarica CSV";
                }
            }

            function downloadCsv(indices) {
                // DEFINIZIONE DELL'ORDINE ESATTO DEI FILTRI
                const FILTER_NAMES = ["FF814W", "FF115W", "FF150W", "FF200W", "FF277W", "FF356W", "FF410M", "FF444W"];

                // 1. Header Anagrafici
                let headers = [
                    "ID", "RA", "DEC", "Z_Phot", "Survey", 
                    "UMAP_X", "UMAP_Y", "ClassStar", "R50_pix", "Ref_Flux"
                ];
                
                // 2. Aggiungiamo gli Header dei Filtri (F_NomeFiltro e E_NomeFiltro)
                FILTER_NAMES.forEach(name => {
                    headers.push(`F_${name}`); // Colonna Flusso (es. F_FF814W)
                    headers.push(`E_${name}`); // Colonna Errore (es. E_FF814W)
                });

                // 3. Costruzione Righe
                const rows = indices.map(idx => {
                    let row = [
                        D.ids[idx],
                        D.ra[idx].toFixed(7),
                        D.dec[idx].toFixed(7),
                        D.zphot[idx].toFixed(4),
                        D.survey[idx],
                        D.umap[idx][0].toFixed(5),
                        D.umap[idx][1].toFixed(5),
                        D.classstar[idx].toFixed(3),
                        D.r50[idx].toFixed(3),
                        D.ref_flux[idx].toExponential(3)
                    ];

                    // Dati Spettro: cicliamo esattamente per il numero di filtri definiti
                    for(let k=0; k < FILTER_NAMES.length; k++) {
                        // Prendiamo il flusso all'indice k, che corrisponde al nome all'indice k
                        row.push(D.fluxes[idx][k].toExponential(4));
                        row.push(D.flux_errors[idx][k].toExponential(4));
                    }
                    return row.join(",");
                });

                // 4. Creazione e Download File
                const csvContent = [headers.join(","), ...rows].join("\n");
                const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement("a");
                link.setAttribute("href", url);
                
                // Nome file dinamico
                const filename = indices.length === 1 
                    ? `galaxy_${D.ids[indices[0]]}.csv` 
                    : `galaxy_selection_N${indices.length}.csv`;
                
                link.setAttribute("download", filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            let currentColorMode = 'catalogs';
            
            const SURVEY_CONFIG = {
                'A2744O':   { field: 'abell2744', url_type: 'jwst', zoom: 9 },
                'CEERSO':   { field: 'egs-v2',    url_type: 'index', zoom: 9 },
                'JADESGNO': { field: 'gdn',       url_type: 'jwst', zoom: 9 },
                'JADESGSO': { field: 'gds',       url_type: 'jwst', zoom: 9 },
                'PRIMERCO': { field: 'cos',       url_type: 'cweb', zoom: 9 },
                'PRIMERUO': { field: 'uds',       url_type: 'index', zoom: 9 }
            };

            function getDjaUrl(ra, dec, survey) {
                const config = SURVEY_CONFIG[survey] || SURVEY_CONFIG['JADESGSO'];
                const base = `https://s3.amazonaws.com/grizli-v2/ClusterTiles/Map/${config.field}`;
                const c = `${ra.toFixed(7)},${dec.toFixed(7)}`;
                if (config.url_type === 'jwst') return `${base}/jwst.html?coord=${c}&zoom=${config.zoom}`;
                if (config.url_type === 'index') return `${base}/index.html?zoom=${config.zoom}&coords=${c}`;
                if (config.url_type === 'cweb') return `${base}/cweb.html?zoom=${config.zoom}&coords=${c}`;
                return `${base}/jwst.html?coord=${c}&zoom=${config.zoom}`;
            }

            function buildUmapTraces() {
                const traces = [];
                // Protezione contro null/undefined
                const catalog_indices = D.catalog_indices || {};
                const catalog_colors = D.catalog_colors || {};
                const catalog_labels = D.catalog_labels || {};
                
                if (currentColorMode === 'catalogs') {
                    const allIndices = Array.from({length: D.ra.length}, (_, i) => i);
                    const specialIndices = new Set();
                                        
                    // Raccogli indici speciali
                    Object.entries(catalog_indices).forEach(([k, arr]) => {
                        if (k === 'Spectroscopic') return; // <--- QUESTA RIGA SALVA I PUNTI GRIGI
                        arr.forEach(idx => specialIndices.add(idx));
                    });
                                        
                    const bgIndices = allIndices.filter(i => !specialIndices.has(i));

                    traces.push({
                        x: bgIndices.map(i => D.umap[i][0]),
                        y: bgIndices.map(i => D.umap[i][1]),
                        customdata: bgIndices,
                        mode: 'markers',
                        type: 'scattergl',
                        marker: { size: 4, color: '#999999', opacity: 0.5, sizemode: 'diameter' },
                        hoverinfo: 'none',
                        name: 'Background'
                    });

                    // 1. Disegna i cataloghi normali (CERCHI)
                    for (const [key, indices] of Object.entries(catalog_indices)) {
                        if (indices.length === 0) continue;
                        if (key === 'Spectroscopic') continue; // Salta Spectroscopic qui

                        traces.push({
                            x: indices.map(i => D.umap[i][0]),
                            y: indices.map(i => D.umap[i][1]),
                            customdata: indices,
                            mode: 'markers',
                            type: 'scattergl',
                            marker: { size: 6, color: catalog_colors[key], line: {color: 'black', width: 0.5} },
                            name: catalog_labels[key],
                            text: indices.map(i => `ID: ${D.ids[i]}`),
                            hovertemplate: '<b>%{text}</b><extra></extra>'
                        });
                    }

                    // 2. Disegna Spectroscopic come OVERLAY (CERCHI TRASPARENTI)
                    if (catalog_indices['Spectroscopic'] && catalog_indices['Spectroscopic'].length > 0) {
                        const specIndices = catalog_indices['Spectroscopic'];
                        traces.push({
                            x: specIndices.map(i => D.umap[i][0]),
                            y: specIndices.map(i => D.umap[i][1]),
                            customdata: specIndices,
                            mode: 'markers',
                            type: 'scattergl',
                            marker: { 
                                symbol: 'square',           // Invece di 'x'
                                size: 6,                    // Leggermente pi√π grande per circondare il punto sotto
                                color: 'rgba(0,0,0,0)',     // Riempimento TRASPARENTE
                                line: {
                                    color: 'purple', 
                                    width: 1             // Spessore del cerchietto
                                }
                            },
                            name: catalog_labels['Spectroscopic'] || 'Spectroscopic',
                            text: specIndices.map(i => `ID: ${D.ids[i]} (Spec)`),
                            hovertemplate: '<b>%{text}</b><extra></extra>'
                        });
                    }
                    
                } else {
                    const allIndices = Array.from({length: D.ra.length}, (_, i) => i);
                    let colorValues, colorLabel, colorscale;
                    
                    if (currentColorMode === 'zphot') {
                        colorValues = D.zphot;
                        colorLabel = 'Photo-z';
                        colorscale = 'Hot';
                    } else if (currentColorMode === 'ref_flux') {
                        colorValues = D.ref_flux.map(f => Math.log10(f + 1e-30));
                        colorLabel = `log10(${D.ref_filter_name})`;
                        colorscale = 'Plasma';
                    } else if (currentColorMode === 'classstar') {
                        colorValues = D.classstar;
                        colorLabel = 'ClassStarSE';
                        colorscale = 'RdYlBu';
                    }
                    
                    traces.push({
                        x: allIndices.map(i => D.umap[i][0]),
                        y: allIndices.map(i => D.umap[i][1]),
                        customdata: allIndices,
                        mode: 'markers',
                        type: 'scattergl',
                        marker: { 
                            size: 4, 
                            color: colorValues,
                            colorscale: colorscale,
                            colorbar: { title: colorLabel, len: 0.7, thickness: 15 },
                            line: {color: 'rgba(0,0,0,0.1)', width: 0.5}
                        },
                        text: allIndices.map(i => `ID: ${D.ids[i]}`),
                        hovertemplate: '<b>%{text}</b><extra></extra>',
                        showlegend: false
                    });

                }
                
                traces.push({
                    x: [], y: [], mode: 'markers', type: 'scattergl',
                    marker: { size: 12, color: 'rgba(0,0,0,0)', line: {color: 'red', width: 2} },
                    name: 'Selected', hoverinfo: 'none', showlegend: false
                });

                traces.push({
                    x: [], y: [], mode: 'markers', type: 'scattergl',
                    marker: { size: 8, color: 'rgba(255,0,0,0.3)', line: {color: 'red', width: 1} },
                    name: 'Multi-Selected', hoverinfo: 'none', showlegend: false
                });
                
                return traces;
            }

            const umapLayout = {
                title: 'UMAP Space', 
                margin: { t: 30, l: 40, r: 20, b: 30 },
                hovermode: 'closest', 
                dragmode: 'pan', 
                legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(255,255,255,0.8)' }
            };

            const sedLayout = {
                title: 'SED Viewer (Observer Frame)', 
                xaxis: { type: 'log', title: 'Wavelength [Œºm]', exponentformat: 'none' }, 
                yaxis: { type: 'log', title: 'Flux [ŒºJy]', exponentformat: 'power' },
                margin: { t: 40, l: 60, r: 20, b: 40 },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };

            const sedRestLayout = {
                title: 'SED Rest-Frame', 
                xaxis: { type: 'log', title: 'Rest Wavelength [Œºm]', exponentformat: 'none' }, 
                yaxis: { type: 'log', title: 'Flux [ŒºJy]', exponentformat: 'power' },
                margin: { t: 40, l: 60, r: 20, b: 40 },
                showlegend: true,
                legend: { x: 0.02, y: 0.98 }
            };

            const histLayout = {
                title: { text: 'SED count per bin', font: { size: 11 } },
                xaxis: { type: 'log', title: '', showticklabels: false },
                yaxis: { title: 'N', titlefont: { size: 11 } },
                margin: { t: 25, l: 50, r: 20, b: 20 },
                showlegend: false,
                bargap: 0.1
            };

            let initialTraces = buildUmapTraces();
            
            Plotly.newPlot('umap-plot', initialTraces, umapLayout, {responsive: true});        
            Plotly.newPlot('sed-plot', [], sedLayout, {responsive: true});
            Plotly.newPlot('sed-rest-plot', [], sedRestLayout, {responsive: true});
            Plotly.newPlot('histogram-plot', [], histLayout, {responsive: true});

            // =====================
            // Barro-style Color‚ÄìColor Diagram
            // =====================
            const FLUX_COLS = ["FF814W","FF115W","FF150W","FF200W","FF277W","FF356W","FF410M","FF444W"]; 
            const band2i = Object.fromEntries(FLUX_COLS.map((b,i)=>[b,i]));
            const i115 = band2i["FF115W"], i200 = band2i["FF200W"], i444 = band2i["FF444W"];

            function colorMag(fA, fB){
                if(!(fA > 0) || !(fB > 0) || !isFinite(fA) || !isFinite(fB)) return null;
                return -2.5 * Math.log10(fA / fB);
            }

            const barroX = D.fluxes.map(row => colorMag(row[i115], row[i200]));
            const barroY = D.fluxes.map(row => colorMag(row[i200], row[i444]));

            function buildBarroTraces(){
                const traces = [];

                // base cloud (gray)
                const bx = [], by = [];
                for(let i=0; i<barroX.length; i++){
                    if(barroX[i] === null || barroY[i] === null) continue;
                    bx.push(barroX[i]); by.push(barroY[i]);
                }
                traces.push({
                    x: bx, y: by,
                    mode: 'markers', type: 'scattergl',
                    marker: { size: 4, color: 'rgba(150,150,150,0.25)' },
                    hoverinfo: 'skip',
                    name: 'All'
                });

                // overlay catalogs (skip BLAGN and Spectroscopic here)
                const catalog_indices = D.catalog_indices || {};
                const catalog_colors  = D.catalog_colors  || {};
                const catalog_labels  = D.catalog_labels  || {};

                // 1. Cataloghi Standard
                for (const [name, idx_list] of Object.entries(catalog_indices)){
                    if(name === 'BLAGN') continue;
                    if(name === 'Spectroscopic') continue; // Salta Spectroscopic per ora
                    if(!idx_list || idx_list.length === 0) continue;
                    const x = [], y = [], text = [];
                    for(const idx of idx_list){
                        if(barroX[idx] === null || barroY[idx] === null) continue;
                        x.push(barroX[idx]); y.push(barroY[idx]);
                        text.push(`ID: ${D.ids[idx]}`);
                    }
                    if(x.length === 0) continue;
                    traces.push({
                        x, y,
                        mode: 'markers', type: 'scattergl',
                        marker: { size: 9, color: catalog_colors[name] || 'C0', line: {color:'black', width:0.6} },
                        name: catalog_labels[name] || name,
                        text,
                        hovertemplate: '<b>%{text}</b><extra></extra>'
                    });
                }

                // 2. Spectroscopic Overlay
                if(catalog_indices['Spectroscopic'] && catalog_indices['Spectroscopic'].length > 0) {
                    const idx_list = catalog_indices['Spectroscopic'];
                    const x = [], y = [], text = [];
                    for(const idx of idx_list){
                        if(barroX[idx] === null || barroY[idx] === null) continue;
                        x.push(barroX[idx]); y.push(barroY[idx]);
                        text.push(`ID: ${D.ids[idx]} (Spec)`);
                    }
                    if(x.length > 0) {
                        traces.push({
                            x, y,
                            mode: 'markers', type: 'scattergl',
                            marker: { 
                                symbol: 'circle', 
                                size: 6, 
                                color: 'rgba(0,0,0,0)',      // Trasparente
                                line: {
                                    color: 'purple',
                                    width: 0.5
                                }
                            },
                            name: catalog_labels['Spectroscopic'] || 'Spectroscopic',
                            text,
                            hovertemplate: '<b>%{text}</b><extra></extra>'
                        });
                    }
                }

                // wedge lines (as scatter line traces)
                traces.push({
                    x: [-0.8, 0.8], y: [1.0, 1.0],
                    mode: 'lines', type: 'scatter',
                    line: {color:'black', width: 2},
                    hoverinfo: 'skip', showlegend: false
                });
                traces.push({
                    x: [0.8, 3.0], y: [1.0, 3.0],
                    mode: 'lines', type: 'scatter',
                    line: {color:'black', width: 2},
                    hoverinfo: 'skip', showlegend: false
                });

                // selection trace (blue open circles)
                traces.push({
                    x: [], y: [],
                    mode: 'markers', type: 'scattergl',
                    marker: { size: 15, color: 'rgba(0,0,0,0)', line: {color:'blue', width: 2.4} },
                    name: 'Selection',
                    hoverinfo: 'skip',
                    showlegend: true
                });

                return traces;
            }

            const barroLayout = {
                title: { text: 'Barro Diagram', font: { size: 12 } },
                xaxis: { title: 'F115W ‚àí F200W  [mag]', range: [-0.8, 3.0] },
                yaxis: { title: 'F200W ‚àí F444W  [mag]', range: [-0.5, 3.5] },
                margin: { t: 35, l: 55, r: 10, b: 45 },
                legend: { x: 0.02, y: 0.98, bgcolor: 'rgba(255,255,255,0.85)' },
                hovermode: 'closest'
            };

            Plotly.newPlot('barro-plot', buildBarroTraces(), barroLayout, {responsive: true});

            function getBarroSelectionTraceIdx(){
                const div = document.getElementById('barro-plot');
                return div.data.length - 1;
            }

            function updateBarroSelection(indices){
                const xs = [], ys = [];
                for(const idx of indices){
                    if(barroX[idx] === null || barroY[idx] === null) continue;
                    xs.push(barroX[idx]); ys.push(barroY[idx]);
                }
                const tIdx = getBarroSelectionTraceIdx();
                Plotly.restyle('barro-plot', {x:[xs], y:[ys]}, [tIdx]);
                const el = document.getElementById('barro-count');
                if(el) el.textContent = `Selected: ${indices.length}`;
            }


            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const mode = this.dataset.mode;
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentColorMode = mode;
                    const newTraces = buildUmapTraces();
                    Plotly.react('umap-plot', newTraces, umapLayout);
                });
            });

            const umapDiv = document.getElementById('umap-plot');
            
            function getSingleMarkerIdx() {
                return umapDiv.data.length - 2;
            }
            
            function getMultiMarkerIdx() {
                return umapDiv.data.length - 1;
            }
            
            umapDiv.on('plotly_click', function(data){
                if(!data.points || data.points.length === 0) return;
                const idx = data.points[0].customdata;
                if (typeof idx === 'undefined') return;
                
                // Aggiorna la selezione globale
                currentSelectionIndices = [idx]; 
                updateDownloadButtonState();     
                updateBarroSelection(currentSelectionIndices);
                
                updateSingleObject(idx);
            });

            umapDiv.on('plotly_selected', function(data){
                if(!data || !data.points || data.points.length === 0) {
                    // Selezione vuota / Deselezione
                    currentSelectionIndices = []; 
                    updateDownloadButtonState();  
                    updateBarroSelection(currentSelectionIndices);
                    
                    Plotly.react('sed-plot', [], sedLayout);
                    Plotly.react('sed-rest-plot', [], sedRestLayout);
                    Plotly.react('histogram-plot', [], histLayout);
                    return;
                }
                const indices = [...new Set(data.points.map(pt => pt.customdata).filter(i => i !== undefined))];
                
                // Aggiorna la selezione globale
                currentSelectionIndices = indices; 
                updateDownloadButtonState();       
                updateBarroSelection(currentSelectionIndices);

                if (indices.length === 1) updateSingleObject(indices[0]);
                else if (indices.length > 1) updateStackedSed(indices);
            });

            function updateSingleObject(idx) {
                const ra = D.ra[idx], dec = D.dec[idx], survey = D.survey[idx], id = D.ids[idx];
                const url = getDjaUrl(ra, dec, survey);
                const z = D.zphot[idx];
                const classstar = D.classstar[idx];
                const r50 = D.r50[idx];
                
                document.getElementById('browser-header').innerHTML = 
                    `<div style="display:flex; flex-direction:column; gap:8px;">
                        <div>
                            <span class="info-tag" style="background:#007bff">ID: ${id}</span>
                            <span class="info-tag" style="background:#28a745">${survey}</span>
                            <span class="info-tag" style="background:#6c757d">z: ${z.toFixed(3)}</span>
                            &nbsp; Coords: ${ra.toFixed(6)}, ${dec.toFixed(6)}
                            &nbsp; <a href="${url}" target="_blank" style="color:#007bff; text-decoration:none;">Open ‚Üó</a>
                        </div>
                        <div class="morph-info">
                            <b>Morphology:</b> ClassStarSE = ${classstar.toFixed(3)} &nbsp;|&nbsp; r50 = ${r50.toFixed(2)} px
                            <span style="color:#666; font-size:0.9em;">
                                ${classstar > 0.8 ? ' (Point-like/Star)' : classstar < 0.3 ? ' (Extended)' : ' (Compact)'}
                            </span>
                        </div>
                    </div>`;
                
                document.getElementById('dja-frame').src = url;
                
                const singleIdx = getSingleMarkerIdx();
                const multiIdx = getMultiMarkerIdx();
                Plotly.restyle('umap-plot', { x: [[]], y: [[]] }, [multiIdx]);
                Plotly.restyle('umap-plot', { x: [[D.umap[idx][0]]], y: [[D.umap[idx][1]]] }, [singleIdx]);

                const xObs = [], yObs = [], errObs = [];
                for(let k=0; k<D.wavelengths.length; k++) {
                    if(D.fluxes[idx][k] > 0) { 
                        xObs.push(D.wavelengths[k]); 
                        yObs.push(D.fluxes[idx][k]);
                        errObs.push(D.flux_errors[idx][k]);
                    }
                }

                sedLayout.title = `Observer Frame: ID ${id}`;
                Plotly.react('sed-plot', [{
                    x: xObs, 
                    y: yObs, 
                    error_y: {
                        type: 'data',
                        array: errObs,
                        visible: true,
                        color: '#d62728',
                        thickness: 1.5,
                        width: 3
                    },
                    mode: 'lines+markers', 
                    name: `ID ${id}`,
                    marker: {size: 8}, 
                    line: {color: '#d62728', width: 2}
                }], sedLayout);

                const xRest = xObs.map(w => w / (1 + z));
                sedRestLayout.title = `Rest Frame: ID ${id} (z=${z.toFixed(3)})`;
                Plotly.react('sed-rest-plot', [{
                    x: xRest, 
                    y: yObs, 
                    error_y: {
                        type: 'data',
                        array: errObs,
                        visible: true,
                        color: '#2ca02c',
                        thickness: 1.5,
                        width: 3
                    },
                    mode: 'lines+markers', 
                    name: `ID ${id}`,
                    marker: {size: 8}, 
                    line: {color: '#2ca02c', width: 2}
                }], sedRestLayout);

                Plotly.react('histogram-plot', [], histLayout);
            }

            function updateStackedSed(indices) {
                const zValues = indices.map(i => D.zphot[i]);
                zValues.sort((a, b) => a - b);
                const medZ = zValues[Math.floor(zValues.length / 2)].toFixed(2);

                const counts = {};
                indices.forEach(i => { counts[D.survey[i]] = (counts[D.survey[i]] || 0) + 1; });
                const compStr = Object.entries(counts).map(([k,v]) => `<b>${k}</b>:${v}`).join(' | ');

                const first = indices[0];
                const url = getDjaUrl(D.ra[first], D.dec[first], D.survey[first]);
                
                document.getElementById('browser-header').innerHTML = `
                    <div style="display:flex; align-items:center; justify-content:space-between;">
                        <div>
                            <span class="info-tag" style="background:#333;">Stacked (N=${indices.length})</span>
                            <span class="stat-tag">Median z: ${medZ}</span>
                            <span style="font-size:0.9em; color:#555; margin-left:10px;">[ ${compStr} ]</span>
                        </div>
                        <div style="font-size:0.85em; color:#777;">
                            Map: ID ${D.ids[first]} <a href="${url}" target="_blank" style="color:#007bff;">Open ‚Üó</a>
                        </div>
                    </div>
                `;
                document.getElementById('dja-frame').src = url;
                
                const singleIdx = getSingleMarkerIdx();
                const multiIdx = getMultiMarkerIdx();
                Plotly.restyle('umap-plot', {x: [[]], y: [[]]}, [singleIdx]);
                Plotly.restyle('umap-plot', {
                    x: [indices.map(i => D.umap[i][0])], 
                    y: [indices.map(i => D.umap[i][1])]
                }, [multiIdx]);

                const mediansObs = [], p16sObs = [], p84sObs = [];
                for (let w = 0; w < D.wavelengths.length; w++) {
                    const vals = [];
                    for (let i of indices) if (D.fluxes[i][w] > 0) vals.push(D.fluxes[i][w]);
                    
                    if (vals.length === 0) { 
                        mediansObs.push(null); p16sObs.push(null); p84sObs.push(null); 
                    } else {
                        vals.sort((a,b) => a - b);
                        mediansObs.push(vals[Math.floor(vals.length * 0.50)]);
                        p16sObs.push(vals[Math.floor(vals.length * 0.16)]);
                        p84sObs.push(vals[Math.floor(vals.length * 0.84)]);
                    }
                }

                sedLayout.title = `Observer Frame (Median z=${medZ})`;
                Plotly.react('sed-plot', [
                    { x: D.wavelengths, y: p16sObs, mode: 'lines', line: {width: 0}, showlegend: false, hoverinfo: 'none' },
                    { x: D.wavelengths, y: p84sObs, mode: 'lines', line: {width: 0}, fill: 'tonexty', fillcolor: 'rgba(214, 39, 40, 0.2)', name: '16-84th Perc.', hoverinfo: 'none' },
                    { x: D.wavelengths, y: mediansObs, mode: 'lines+markers', line: {color: '#d62728', width: 2}, name: `Median` }
                ], sedLayout);

                function quantileSorted(sortedArr, q) {
                    if (sortedArr.length === 0) return null;
                    const pos = (sortedArr.length - 1) * q;
                    const base = Math.floor(pos);
                    const rest = pos - base;
                    if (sortedArr[base + 1] !== undefined) {
                        return sortedArr[base] + rest * (sortedArr[base + 1] - sortedArr[base]);
                    }
                    return sortedArr[base];
                }

                function log10(x) { return Math.log(x) / Math.LN10; }

                const allRestWaves = [];
                for (let i of indices) {
                    const z = D.zphot[i];
                    if (!isFinite(z) || z <= -0.5) continue;
                    for (let w = 0; w < D.wavelengths.length; w++) {
                        const flux = D.fluxes[i][w];
                        if (flux > 0) allRestWaves.push(D.wavelengths[w] / (1 + z));
                    }
                }

                if (allRestWaves.length === 0) {
                    sedRestLayout.title = `Rest Frame: No valid data`;
                    Plotly.react('sed-rest-plot', [], sedRestLayout);
                    Plotly.react('histogram-plot', [], histLayout);
                    return;
                }

                allRestWaves.sort((a, b) => a - b);
                const restWavelengthMin = allRestWaves[0];
                const restWavelengthMax = allRestWaves[allRestWaves.length - 1];

                const nBins = 30;
                const logMin = log10(restWavelengthMin);
                const logMax = log10(restWavelengthMax);
                const restBins = Array.from({length: nBins}, (_, b) =>
                    Math.pow(10, logMin + (logMax - logMin) * b / (nBins - 1))
                );

                const restBinsLog = restBins.map(x => Math.log(x));

                const mat = [];
                const usedObj = [];
                for (let i of indices) {
                    const z = D.zphot[i];
                    if (!isFinite(z) || z <= -0.5) continue;

                    const xs = [];
                    const ys = [];
                    for (let w = 0; w < D.wavelengths.length; w++) {
                        const flux = D.fluxes[i][w];
                        if (!(flux > 0)) continue;
                        const rw = D.wavelengths[w] / (1 + z);
                        if (isFinite(rw) && isFinite(flux)) {
                            xs.push(rw);
                            ys.push(flux);
                        }
                    }

                    if (xs.length < 2) continue;

                    const order = xs.map((x, idx) => [x, idx]).sort((a,b) => a[0] - b[0]).map(p => p[1]);
                    const xSorted = order.map(j => xs[j]);
                    const ySorted = order.map(j => ys[j]);

                    const xLog = xSorted.map(v => Math.log(v));
                    const row = new Array(nBins).fill(null);

                    const xmin = xLog[0];
                    const xmax = xLog[xLog.length - 1];

                    let j = 0;
                    for (let b = 0; b < nBins; b++) {
                        const xb = restBinsLog[b];
                        if (xb < xmin || xb > xmax) {
                            row[b] = null
                            continue;
                        }

                        while (j < xLog.length - 2 && xLog[j + 1] < xb) j++;

                        const x0 = xLog[j], x1 = xLog[j + 1];
                        const y0 = ySorted[j], y1 = ySorted[j + 1];

                        if (!(isFinite(x0) && isFinite(x1) && isFinite(y0) && isFinite(y1)) || x1 === x0) {
                            row[b] = null;
                            continue;
                        }

                        const t = (xb - x0) / (x1 - x0);
                        const yb = y0 + t * (y1 - y0);
                        row[b] = (isFinite(yb) && yb > 0) ? yb : null;
                    }

                    mat.push(row);
                    usedObj.push(i);
                }

                if (mat.length < 2) {
                    const sedRestLayoutUpdate = {...sedRestLayout};
                    sedRestLayoutUpdate.title = `Rest Frame: insufficient objects`;
                    Plotly.react('sed-rest-plot', [], sedRestLayoutUpdate);
                    Plotly.react('histogram-plot', [], histLayout);
                    return;
                }

                const mediansRest = new Array(nBins).fill(null);
                const p16sRest = new Array(nBins).fill(null);
                const p84sRest = new Array(nBins).fill(null);
                const binCounts = new Array(nBins).fill(0);

                for (let b = 0; b < nBins; b++) {
                    const vals = [];
                    for (let r = 0; r < mat.length; r++) {
                        const v = mat[r][b];
                        if (v !== null && isFinite(v)) vals.push(v);
                    }
                    binCounts[b] = vals.length;

                    if (vals.length === 0) continue;

                    vals.sort((a, b) => a - b);
                    p16sRest[b] = quantileSorted(vals, 0.16);
                    mediansRest[b] = quantileSorted(vals, 0.50);
                    p84sRest[b] = quantileSorted(vals, 0.84);
                }

                const sedRestLayoutUpdate = {...sedRestLayout};
                sedRestLayoutUpdate.title = `Rest Frame (Median z=${medZ}, N=${indices.length})`;
                sedRestLayoutUpdate.xaxis = {
                    ...sedRestLayout.xaxis,
                    range: [log10(restWavelengthMin * 0.9), log10(restWavelengthMax * 1.1)]
                };

                Plotly.react('sed-rest-plot', [
                    { x: restBins, y: p16sRest, mode: 'lines', line: {width: 0}, showlegend: false, hoverinfo: 'none' },
                    { x: restBins, y: p84sRest, mode: 'lines', line: {width: 0}, fill: 'tonexty',
                    fillcolor: 'rgba(44, 160, 44, 0.2)', name: '16-84th Perc.', hoverinfo: 'none' },
                    { x: restBins, y: mediansRest, mode: 'lines+markers',
                    line: {color: '#2ca02c', width: 2}, marker: {size: 4}, name: `Median Rest` }
                ], sedRestLayoutUpdate);

                const histLayoutUpdate = {...histLayout};
                histLayoutUpdate.title.text = `SED count per bin (max=${Math.max(...binCounts)})`;
                histLayoutUpdate.xaxis = {
                    ...histLayout.xaxis,
                    range: [log10(restWavelengthMin * 0.9), log10(restWavelengthMax * 1.1)]
                };

                Plotly.react('histogram-plot', [{
                    x: restBins,
                    y: binCounts,
                    type: 'lines', 
                    marker: { color: '#1f77b4', opacity: 0.7 }
                }], histLayoutUpdate);
            }

        } catch (e) {
            showError(e.message + "\n" + e.stack);
        }
    }
</script>
</body>
</html>